# WMCTF2022

### ECC

> flag bits: 606
>
> e = 0x10001
>
> n = 61262574892917665379101848600282751252633178779864648655116434051615964747592676204833262666589440081296571836666022795166255640192795587508845265816642144669301520989571990670507103278098950563219296310830719975959589061794360407053224254135937766317251283933110936269282950512402428088733821277056712795259
>
> c = 16002162436420434728223131316901476099110904029045408221515087977802746863468505266500673611412375885221860212238712311981079623398373906773247773552766200431323537510699147642358473715224124662007742017000810447999989426207919068340364725395075614636875116086496704959130761547095168937180751237132642548997
>
> G = (3364552845709696244757995625685399274809023621531082895612949981433844727622567352338990765970534554565693355095508508160162961299445890209860508127449468 : 4874111773041360858453223185020051270111929505293131058858547656851279111764112235653823943997681930204977283843433850957234770591933663960666437259499093 : 1)
>
> 3G = (8240596254289477251157504980772167439041663401504657696787046343848644902166655624353107697436635678388969190302189718026343959470011854412337179727187240 : 4413479999185843948404442728411950785256136111461847698098967018173326770728464491960875264034301169184074110521039566669441716138955932362724194843596479 : 1)

要解决的问题是：已知$$G$$​和$$3G$$​，算出椭圆曲线$$y^2 \equiv x^3 + ax + b \pmod{p}$$​上的$$a$$​和$$b$$​

对椭圆曲线变换得到$$y^2 - x^3 - ax \equiv b \pmod{p}$$，将两个点代入得到$$b_1=b+k_1p$$，$$b_2 = b + k_2p$$，相减和$$n$$​取GCD得到$$p$$​，根据RSA定义得到$$q=\frac{n}{p}$$，$$a$$的值同理

因为$$G+2G=3G$$​，根据椭圆曲线上的加法规则，先计算出$$2G$$​，再算出$$a$$

$$
\begin{aligned}
	& \lambda = (3x_0+a)(2y_0)^{-1} \pmod{p}\\
	& x_1 = \lambda^2 - 2x_0\\
	& y_1 = \lambda(x_0 - x_1) - y_0
\end{aligned}
$$

$$
\begin{aligned}
	& \lambda^{'} = (y_1 - y_0)(x_1-x_0)^{-1} \pmod{p}\\
	& x_3 = {\lambda^{'}}^{2} - x_0 - x_1\\
	& y_3 = {\lambda^{'}}(x_0 - x_3) - y_0
\end{aligned}
$$

$$
\begin{aligned}
	& {\lambda^{'}} = \frac{y_3 + y_0}{x_0 - x_3}\\
	& {\lambda^{'}}^2 = x_0 + x_1 + x_3 = \lambda^2 + (x_3 - x_0)\\
\Rightarrow & \lambda^2 = {\lambda^{'}}^2 - (x_3 - x_0)\\
	& {\lambda^{'}} = \frac{(3x_0 - \lambda^2) - 2y_0}{\lambda^2 - 3x_0} = -\lambda - \frac{2y_0}{\lambda^2 - 3x_0}\\
\Rightarrow & \lambda = \frac{\lambda^{'}(\lambda^2 - 3x_0) + 2y_0}{3x_0 - \lambda^2}\\
	& a = 2y_0\lambda - 3x_0^2
\end{aligned}
$$

得到$$p$$​和$$q$$​之后，就可以计算出公钥，按RSA解密密文得到$$c$$​，将$$a$$​、$$b$$​、$$c$$​拼接得到flag

```python
from Crypto.Util.number import *
n = 61262574892917665379101848600282751252633178779864648655116434051615964747592676204833262666589440081296571836666022795166255640192795587508845265816642144669301520989571990670507103278098950563219296310830719975959589061794360407053224254135937766317251283933110936269282950512402428088733821277056712795259
ct = 16002162436420434728223131316901476099110904029045408221515087977802746863468505266500673611412375885221860212238712311981079623398373906773247773552766200431323537510699147642358473715224124662007742017000810447999989426207919068340364725395075614636875116086496704959130761547095168937180751237132642548997
x0,y0 = (3364552845709696244757995625685399274809023621531082895612949981433844727622567352338990765970534554565693355095508508160162961299445890209860508127449468 , 4874111773041360858453223185020051270111929505293131058858547656851279111764112235653823943997681930204977283843433850957234770591933663960666437259499093 )
x3,y3 = (8240596254289477251157504980772167439041663401504657696787046343848644902166655624353107697436635678388969190302189718026343959470011854412337179727187240 , 4413479999185843948404442728411950785256136111461847698098967018173326770728464491960875264034301169184074110521039566669441716138955932362724194843596479 )
fbits = 606
lambda_0 = ((y3 + y0) * inverse(x0 - x3, n)) % n
lambda_12 = (lambda_0 ** 2 - (x3 - x0)) % n
lambda_1 = ((lambda_0 * (lambda_12 - 3 * x0) + 2 * y0) * inverse(3 * x0 - lambda_12, n)) % n
a_1 = (2 * y0 * lambda_1 - 3 * x0 ** 2) % n

b_1 = y0 ** 2 - x0 ** 3 - a_1 * x0
b_2 = y3 ** 2 - x3 ** 3 - a_1 * x3

p = GCD(b_1 - b_2, n)
q = n // p

a = a_1 % p
b = b_1 % p

e = 0x10001
d = inverse(e, (p - 1) * (q - 1))

c = pow(ct, d, n)

part = fbits // 3

flag = (a << (2 * part)) + (b << (1 * part)) + c

print(b'wmctf{'+long_to_bytes(flag)+b'}')
```

### homo

{% embed url="https://martinralbrecht.wordpress.com/2020/03/21/the-approximate-gcd-problem/" %}
